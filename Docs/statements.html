<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="style.css">
		<title>Язык EGSL</title>
	</head>
	<body>
		<h1>Операторы языка</h1>

		<h2>Пустой оператор</h2>
		Ничего не делает. Синтаксис:
		<p>';'</p>

		<h2>Оператор-блок</h2>
		Содержит другие опреаторы. Синтаксис:
		<p>'{' { ОПЕРАТОРЫ } '}'</p>

		<h2>Оператор возврата</h2>
		Приводит к немедленному завершению выполнения шейдера. Синтаксис:
		<p>'return' ';'</p>

		<h2>Оператор отклонения</h2>
		Доступен только в пиксельном шейдере. Завершает выполнение шейдера и исключает данный пиксель из финальной композиции. Синтаксис:
		<p>'discard' ';'</p>

		<h2>Оператор выражения</h2>
		Вычисляет выражение с использованием операций языка. Приоритеты операций и их доступность см. ниже.
		<p> ВЫРАЖЕНИЕ ';'</p>

		<h2>Оператор объявления переменной</h2>
		Создаёт переменную с заданным именем и типом. Записывает в неё значение выражения, если выражение указано.
		<p> ОБЪЯВЛЕНИЕ_ПЕРЕМЕННЫХ ';'</p>

		<h2>Оператор условного ветвления</h2>
		Выполняет одну из ветвей кода в зависимости от значения логического выражения (типа bool).
		<p>'if' '(' ВЫРАЖЕНИЕ ')' ОПЕРАТОР [ 'else' ОПЕРАТОР ]</p>

		<h2>Оператор while</h2>
		Выполняет оператор пока истинно логическое выражение (проверка выражения до выполнения).
		<p>'while' '(' ВЫРАЖЕНИЕ ')' ОПЕРАТОР</p>

		<h2>Оператор do-while</h2>
		Выполняет оператор пока истинно логическое выражение (проверка выражения после выполнения).
		<p>'do' ОПЕРАТОР 'while' '(' ВЫРАЖЕНИЕ ')' ';'</p>

		<h2>Оператор for</h2>
		<p>'for' '(' ( ОБЪЯВЛЕНИЕ_ПЕРЕМЕННЫХ | ВЫРАЖЕНИЕ ) ';' УСЛОВИЕ ';' ДЕЙСТВИЕ ')' ОПЕРАТОР</p>
		Эквивалент
		<p>( ОБЪЯВЛЕНИЕ_ПЕРЕМЕННЫХ | ВЫРАЖЕНИЕ ) ';' 'while' '(' УСЛОВИЕ ')' '{' ОПЕРАТОР ДЕЙСТВИЕ ';' '}'</p>
		УСЛОВИЕ имеет возвращаемое значение типа bool. ДЕЙСТВИЕ имеет любое возвращаемое значение.

		<h2>Оператор выхода из цикла</h2>
		Прерывает выполнение тела цикла и передаёт управление на следующий после цикла оператор.
		<p>'break' ';'</p>

		<h2>Оператор замыкания цикла</h2>
		Прерывает выполнение тела цикла и передаёт управление на следующую итерацию цикла.
		<p>'continue' ';'</p>

		<h1>Синтаксис объявления перемнных</h1>
		<p>ТИП ИНИЦИАЛИЗАЦИЯ_ПЕРЕМЕННОЙ { ',' ИНИЦИАЛИЗАЦИЯ_ПЕРЕМЕННОЙ }</p>
		Тип может быть элементарным или пользовательским.
		Синтаксис инициализации переменной:
		<p>ИМЯ [ '[' РАЗМЕР ']' ] [ '=' ( ВЫРАЖЕНИЕ | '{' ВЫРАЖЕНИЕ ... ВЫРАЖЕНИЕ '}' ) ] </p>
		Выражение задаёт начальное значение и имеет тип, совместимый с переменной.
		Если указан размер, то создаётся конечный массив, размер - целочисленный литерал \gt 0.
		Инициализатор с несколькими выражениями допускается только для массивов.
		Количество выражений не должно быть больше размерности массива.

		<h1>Операции и их приоритеты</h1>
		Операции приведены в порядке возрастания приоритета.
		<h2>= += -= *= /= %= &= |= ^= &lt;&lt;= &gt;&gt;=</h2>
		Оператор присваивания и производные. Бинарные операции. Левый аргумент должен быть присваиваемым.
		Присваиваемыми являются переменные, out аргументы, результаты операций '.' и '[]', применённых к присваиваемым величинам.
		Тип правого аргумента должен допускать неявное приведение к левому типу.
		Для производных операций должна поддерживаться соответствующая операция на используемом типе.
		Типом выражения является тип левой части. Результат является присваиваемым.
		<h2>?:</h2>
		Тринарный оператор.
		Левый аргумент должен допускать неявное приведение к типу bool.
		Целочисленный и правый аргументы должны быть идентичного типа.
		Результат операции имеет тип, идентичный типу центрального аргумента.
		<h2>||</h2>
		Логическое 'или'. Бинарный. Аргументы имеют скалярные или векторные типы одинаковой размерности.
		(HLSL: допускаются матрицы.) Результатом выражения является bool: скаляр, вектор или матрица той же размерности.
		<h2>&&</h2>
		Логическое 'и'. Бинарный. Аргументы имеют скалярные или векторные типы одинаковой размерности.
		(HLSL: допускаются матрицы.) Результатом выражения является bool: скаляр, вектор или матрица той же размерности.
		<h2>== != &lt;= &gt;= &lt; &gt;</h2>
		Операции сравнения. Бинарные. Аргументы имеют скалярные или векторные типы одинаковой размерности.
		(HLSL: допускаются матрицы.) Результатом выражения является bool: скаляр, вектор или матрица той же размерности.
		<h2>+ - | ^ &lt;&lt; &gt;&gt;</h2>
		Бинарные. Левый и правый аргументы имеют элементарные типы одинаковой размерности, допускающие неявное приведение к единому типу.
		Также допускается пара аргументов 'скаляр' и произвольная размерность.
		Результат имеет единый тип той же размерности.<br>
		Операции + и - применимы к любым элементарным типам.<br>
		Операции | ^ &lt;&lt; и &gt;&gt; применимы только к скалярам или векторам bool, int или uint (HLSL: и матрицам).
		<h2>* / % &</h2>
		Бинарные. Левый и правый аргументы имеют элементарные типы одинаковой размерности, допускающие неявное приведение к единому типу.
		Также допускается пара аргументов 'скаляр' и произвольная размерность.
		Результат имеет единый тип той же размерности.<br>
		Операции * и / применимы только к скалярам или векторам (HLSL: и матрицам). (Metal: * применимо к паре скаляр-матрица.)<br>
		Операции % и & применимы только к скалярам или векторам bool, int или uint (HLSL: и матрицам).
		<h2>+ - ! ~</h2>
		Унарные. Аргумент следует после операции. Может иметь любой элементарный тип, быть скаляром или вектором (HLSL: и матрицей).<br>
		Операции + и - применимы к любым типам и имеют результатом этот тип.<br>
		Операция ! применима к любым типам и имеет результатом тип bool (размерности аргумента).<br>
		Операция ~ применима к типам bool, int и uint и имеет результатом этот же тип.
		<h2>. [] ++ --</h2>
		<h3>++ --</h3>
		Операции ++ и -- применимы ко всем элементарным типам, скалярам, векторам (HLSL: и матрицам).
		Аргумент должен быть присваиваемым. Результат операции не является присваиваемым. Имеет идентичный аргументу тип.
		<h3>.</h3>
		Правый аргумент - имя поля. Левый аргумент - векторный элементарный тип или пользовательский тип.
		Результат имеет тип поля. Пользовательские типы имеют поля, объявленные пользователем.
		Векторные типы имеют поля, имена которых являются произвольными комбинациями от 1 до 4 букв 'xyzwargbuv'.
		Имеют базовый тип идентичный типу вектора и размерность, равную количеству букв.
		Буквы 'xru' соответствуют первой компоненте вектора, буквы 'ygv' - второй, 'zb' - третьей, 'wa' - четвёртой.
		Поле допускает присваивание тогда и только тогда, когда среди букв нет пары, идентифицирующей одну и ту же компоненту.
		<h3>[]</h3>
		Выражение в скобках назовём индексом.<br>
		Для аргументов - статических массивов индекс должен иметь тип, совместимый с int. Результат выражения является присваиваемым.<br>
		Для аргументов - массивов (array) индекс должен иметь тип, совместимый с int. Результат выражения не является присваиваемым.<br>
		Для аргументов - текстур индекс должен быть вектором типа int размерности на единицу выше размерности текстуры. Кубические текстуры и их массивы не поддерживаются.
		Компоненты индекса задают координаты в текстуре в порядке x - y - z - индекс текстуры в массиве - индекс уровня детализации.<br>
		Для аргументов - векторов и матриц - индекс должен иметь тип int и задаёт индекс компоненты вектора/строки матрицы (начиная с 0).
		<h2>() f f()</h2>
		() имеет тот же тип, что и аргумент, но не является присваиваемым.<br>
		f может быть литералом (целочисленным (int), вещественным (float) или логическим (bool) - 'true' или 'false'),
		именем аргумента шейдера, именем переменной или именем константы.
		В языке доступны константы: C_PI, C_2PI, C_PI2, C_PI3, C_PI4, C_PI6, C_E.<br>
		f() определяет вызов <a href="functions.html">встроенной функции</a> или явное приведение типа (если f это тип).
		Явное приведение типов поддерживается только для элементарных типов.
	</body>
</html>